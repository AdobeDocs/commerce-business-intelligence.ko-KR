---
title: 고급 계산 열 유형
description: 대부분의 사용 열 사례에 대한 기본 사항을 알아봅니다. 하지만 Data Warehouse Manager가 만들 수 있는 것보다 더 복잡한 계산된 열이 필요할 수 있습니다.
exl-id: 9871fa19-95b3-46e4-ae2d-bd7c524d12db
role: Admin, Data Architect, Data Engineer, User
feature: Commerce Tables, Data Warehouse Manager
source-git-commit: 6e2f9e4a9e91212771e6f6baa8c2f8101125217a
workflow-type: tm+mt
source-wordcount: '930'
ht-degree: 2%

---

# 고급 계산 열 유형

만들려는 많은 분석에는 **또는**&#x200B;하려는 `group by`새 열`filter by`을 사용해야 할 수 있습니다. [계산된 열 만들기](../data-warehouse-mgr/creating-calculated-columns.md) 자습서에서는 대부분의 사용 사례에 대한 기본 사항을 다루지만 Data Warehouse Manager가 만들 수 있는 것보다 복잡한 계산된 열을 원할 수도 있습니다.
{: #top}

Data Warehouse 분석가의 Adobe 팀에서 이러한 유형의 열을 만들 수 있습니다. 새 계산된 열을 정의하려면 다음 정보를 제공합니다.

1. 이 열의 **`definition`**(입력, 수식 또는 서식 포함)
1. 열을 만들 **`table`**
1. 열에 포함해야 하는 항목을 설명하는 모든 **`example data points`**

다음은 사용자가 종종 유용하다고 생각하는 고급 계산 열의 몇 가지 일반적인 예입니다.

* [순차적으로 이벤트 순서 지정(또는 등급 지정)](#compareevents)
* [두 이벤트 사이의 시간 찾기](#twoevents)
* [순차적 이벤트 값 비교](#sequence)
* [통화 전환](#currency)
* [시간대 변환](#timezone)
* [다른 항목](#else)

## 이벤트를 순차적으로 주문하려고 합니다. {#compareevents}

이를 **이벤트 번호** 계산 열이라고 합니다. 즉, 고객 또는 사용자와 같은 특정 이벤트 소유자에 대해 이벤트가 발생한 시퀀스를 찾으려고 합니다.

예를 들면 다음과 같습니다.

| **`event\_id`** | **`owner\_id`** | **`timestamp`** | **`Owner's event number`** |
|-----|-----|-----|-----|
| 1 | `A` | 2015-01-01 00:00:00 | 1 |
| 2 | `B` | 2015-01-01 00:30:00 | 1 |
| 3 | `A` | 2015-01-01 02:00:00 | 2 |
| 4 | `A` | 2015년 1월 2일 13일:00:0 | 3 |
| 5 | `B` | 2015년 1월 3일 13일:00:0 | 2 |

{style="table-layout:auto"}

이벤트 번호 계산 열을 사용하여 데이터에서 첫 번째 이벤트, 반복 이벤트 또는 n번째 이벤트 간의 동작 차이를 관찰할 수 있습니다.

고객의 주문 번호 열이 작동 중인지 확인하고 싶습니까? 이미지를 클릭하여 보고서에서 그룹화 기준 차원으로 사용되는 것을 확인합니다.

![이벤트 번호 계산 열을 사용하여 고객의 주문 번호로 그룹화합니다.](../../assets/EventNumber.gif)<!--{: style="max-width: 500px;"}-->

이 유형의 계산된 열을 만들려면 다음을 알아야 합니다.

* 이 열을 생성할 테이블입니다.
* 이벤트 소유자(이 예제에서는 `owner\_id`)를 식별하는 필드입니다.
* 이벤트 순서를 지정할 필드(이 예제에서는 `timestamp`)

[위로 돌아가기](#top)

## 나는 두 사건 사이의 시간을 찾으려고 노력하고 있다. {#twoevents}

이를 `date difference` 계산 열이라고 합니다. 즉, 이벤트 타임스탬프를 기반으로 단일 레코드에 속하는 두 이벤트 사이의 시간을 찾습니다.

예를 들면 다음과 같습니다.

| `id` | `timestamp\_1` | `timestamp\_2` | `Seconds between timestamp\_2 and timestamp\_1` |
|-----|-----|-----|-----|
| `A` | 2015-01-01 00:00:00 | 2015년 1월 1일 12일:30:0 | 45000 |
| `B` | 2015-01-01 08:00:00 | 2015-01-01 10:00:0 | 7200 |

{style="table-layout:auto"}

날짜 차이 계산 열을 사용하여 두 이벤트 간의 평균 또는 중간 시간을 계산하는 지표를 만들 수 있습니다. 보고서에서 `Average time to first order` 지표가 사용되는 방식을 확인하려면 아래 이미지를 클릭하십시오.

![날짜 차이 계산 열을 사용하여 첫 번째 주문까지의 평균 시간을 계산합니다.](../../assets/DateDifference.gif)<!--{: style="max-width: 500px;"}-->

이 유형의 계산된 열을 만들려면 다음을 알아야 합니다.

* 이 열을 생성할 테이블입니다.
* 차이를 알고 싶은 두 타임스탬프

[위로 돌아가기](#top)

## 순차적 이벤트 값을 비교하려고 합니다. {#sequence}

이를 **순차적 이벤트 비교**&#x200B;라고 합니다. 즉, 값(통화, 숫자, 타임스탬프)과 소유자의 이전 이벤트에 대한 해당 값 사이의 델타를 찾으려고 합니다.

예를 들면 다음과 같습니다.

| **`event\_id`** | **`owner\_id`** | **`timestamp`** | **`Seconds since owner's previous event`** |
|-----|-----|-----|-----|
| 1 | `A` | 2015-01-01 00:00:00 | NULL |
| 2 | `B` | 2015-01-01 00:30:00 | NULL |
| 3 | `A` | 2015-01-01 02:00:00 | 7720 |
| 4 | `A` | 2015년 1월 2일 13일:00:0 | 126000 |
| 5 | `B` | 2015년 1월 3일 13일:00:0 | 217800 |

{style="table-layout:auto"}

순차적 이벤트 비교는 각각의 순차적 이벤트 사이의 평균 또는 중간 시간을 찾는 데 사용될 수 있다. 작동 중인 **주문 간 평균 및 중간 시간** 지표를 보려면 아래 이미지를 클릭하십시오.

=![순차적 이벤트 비교 계산 열을 사용하여 주문 간 평균 및 중간값 시간을 계산합니다.](../../assets/SeqEventComp.gif)<!--{: style="max-width: 500px;"}-->

이 유형의 계산된 열을 만들려면 다음을 알아야 합니다.

* 이 열을 생성할 테이블입니다.
* 이벤트의 소유자를 식별하는 필드입니다(이 예제에서는 `owner\_id`).
* 각 순차적 이벤트의 차이를 확인할 값 필드(이 예제에서는 `timestamp`)

[위로 돌아가기](#top)

## 통화를 전환하려고 합니다. {#currency}

**통화 전환** 계산 열은 이벤트 시점의 환율을 기준으로 거래 금액을 기록된 통화에서 보고 통화로 변환합니다.

예를 들면 다음과 같습니다.

| **`id`** | **`timestamp`** | **`transaction\_value\_EUR`** | **`transaction\_value\_USD`** |
|-----|-----|-----|-----|
| `1` | 2015-01-01 00:00:00 | 30 | 33.57 |
| `2` | 2015-01-02 00:00:0 | 50 | 55.93 |

{style="table-layout:auto"}

이 유형의 계산된 열을 만들려면 다음을 알아야 합니다.

* 이 열을 생성할 테이블입니다.
* 변환할 거래 금액 열
* 데이터가 기록된 통화를 나타내는 열(일반적으로 ISO 코드)
* 기본 보고 통화

[위로 돌아가기](#top)

## 시간대를 전환하려고 합니다. {#timezone}

**표준 시간대 변환** 계산 열은 특정 데이터 원본에 대한 타임스탬프를 기록된 표준 시간대에서 보고 표준 시간대로 변환합니다.

예를 들면 다음과 같습니다.

| **`id`** | **`timestamp\_UTC`** | **`timestamp\_ET`** |
|-----|-----|-----|
| `1` | 2015-01-01 00:00:00 | 2014-12-31 19:00:00 |
| `2` | 2015년 1월 1일 12일:00:0 | 2015-01-01 07:00:00 |

{style="table-layout:auto"}

이 유형의 계산된 열을 만들려면 다음을 알아야 합니다.

* 이 열을 생성할 테이블입니다.
* 변환할 타임스탬프 열입니다.
* 데이터가 기록된 시간대입니다
* 기본 보고 시간대

[위로 돌아가기](#top)

## 여기에 나열되지 않은 작업을 하려고 합니다. {#else}

걱정하지 마세요. 여기에 나열되어 있지 않다고 해서 가능하지 않은 것은 아니다. Data Warehouse 분석가 Adobe 팀이 도움을 줄 수 있습니다.

새 계산된 열을 정의하려면 빌드할 내용에 대한 세부 정보를 포함하여 [지원 티켓을 제출](https://experienceleague.adobe.com/docs/commerce-knowledge-base/kb/troubleshooting/miscellaneous/mbi-service-policies.html)합니다.

## 관련 설명서

* [계산된 열 만들기](../data-warehouse-mgr/creating-calculated-columns.md)
* [계산된 열 유형](../data-warehouse-mgr/calc-column-types.md)
* [주문 및 고객 데이터를 사용하여  [!DNL Google ECommerce] 차원 작성](../data-warehouse-mgr/bldg-google-ecomm-dim.md)
