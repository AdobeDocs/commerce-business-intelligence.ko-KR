---
title: SQL 쿼리 최적화
description: SQL 쿼리를 최적화하는 방법을 알아봅니다.
exl-id: 2782c707-6a02-4e5d-bfbb-eff20659fbb2
source-git-commit: fa954868177b79d703a601a55b9e549ec1bd425e
workflow-type: tm+mt
source-wordcount: '828'
ht-degree: 0%

---

# SQL 쿼리 최적화

SQL Report Builder을 사용하면 지정된 시간에 해당 쿼리를 쿼리하고 반복할 수 있습니다. 이 기능은 작성한 열이나 보고서를 업데이트해야 하므로 업데이트 주기가 완료될 때까지 기다리지 않고 쿼리를 수정해야 할 때 유용합니다.

쿼리를 실행하기 전에 [[!DNL MBI] 비용 추정](https://experienceleague.adobe.com/docs/commerce-knowledge-base/kb/troubleshooting/miscellaneous/sql-queries-explain-cost-errors.html?lang=en). 비용은 쿼리를 실행하는 데 필요한 시간 및 리소스 수를 고려합니다. 해당 비용이 너무 높거나 반환된 행 수가 한도를 초과하는 경우 쿼리가 실행되지 않습니다. 데이터 웨어하우스를 쿼리하기 위한 권장 사항 목록을 가져와서 가능한 가장 능률적인 쿼리를 작성하고 있습니다.

## SELECT 또는 모든 열 선택 사용

모든 열을 선택해도 적시에 쉽게 실행되는 쿼리에 적합하지 않습니다. 를 사용하는 쿼리 `SELECT *` 테이블에 열이 많은 경우, 특히 실행하는 데 시간이 꽤 걸릴 수 있습니다.

이러한 이유로 `SELECT *` 가능한 모든 위치와 필요한 열만 포함합니다.

| **이 대신...** | **한번 해 봐!** |
|-----|-----|
| ![](../../mbi/assets/Select_all_1.png) | ![](../../mbi/assets/Select_all_2.png) |

{style=&quot;table-layout:auto&quot;}

## 전체 외부 조인 사용

외부 조인은 결합되는 두 테이블 전체를 선택하여 쿼리의 계산 비용을 증가시킵니다. 즉, 결과를 반환하는 데 실행 제한보다 시간이 오래 걸릴 수 있으므로 쿼리가 실행되는 데 시간이 오래 걸리고 실패할 가능성이 높습니다.

이러한 유형의 조인을 사용하는 대신 내부 또는 왼쪽 조인을 사용하는 것이 좋습니다. 내부 조인은 테이블 간의 열 일치(예: `order_id` 는 두 가지 일반적인 `customers` 및 `orders` 표); 왼쪽 조인은 오른쪽(두 번째) 테이블의 일치하는 결과와 함께 왼쪽(첫 번째) 테이블의 모든 결과를 반환합니다.

전체 외부 조인 쿼리를 다시 작성하는 방법을 살펴보십시오.

| **이 대신...** | **한번 해 봐!** |
|-----|-----|
| ![](../../mbi/assets/Full_Outer_Join_1.png) | ![](../../mbi/assets/Full_Outer_Join_2.png) |

{style=&quot;table-layout:auto&quot;}

볼 수 있듯이 이러한 쿼리는 사용하는 JOIN 유형을 제외하고 모든 방법으로 동일합니다.

## 여러 조인 사용

쿼리에 여러 조인을 포함할 수 있지만 쿼리 비용을 높일 수 있습니다. 비용 임계값에 도달하지 않도록 가능하면 여러 조인을 사용하지 않는 것이 좋습니다.

## 필터 사용

가능하면 필터를 사용하십시오. `WHERE` 및 `HAVING` 절은 결과를 필터링하고 원하는 데이터만 제공합니다.

## JOIN 절에 필터 사용

조인을 수행할 때 필터를 사용하는 경우 조인의 두 테이블에 필터를 적용해야 합니다. 중복되는 경우에도 쿼리의 계산 비용을 줄이고 실행 시간을 단축합니다.

| **이 대신...** | **한번 해 봐!** |
|-----|-----|
| ![](../../mbi/assets/Join_filters_1.png) | ![](../../mbi/assets/Join_filters_2.png) |

{style=&quot;table-layout:auto&quot;}

## 연산자 사용

쿼리를 작성할 때는 가능한 &#39;가장 저렴한&#39; 연산자를 사용하는 것이 좋습니다. 모든 쿼리에는 계산 비용이 있으며 쿼리를 구성하는 함수, 연산자 및 필터에 의해 결정됩니다. 일부 연산자는 계산 노력이 덜 필요하므로 다른 연산자보다 비용이 적게 듭니다.

비교 연산자(>, &lt;, = 등)가 가장 저렴하고 뒤에 가 옵니다 [좋아요 및 POSIX 연산자와 유사](https://www.postgresql.org/docs/9.5/functions-matching.html) 가장 비싼 작업자가 어디 있죠?

## 존재와 IN 사용

사용 `EXISTS` 비교 `IN` 반환하려는 결과 유형에 따라 달라집니다. 단일 값만 알고 싶은 경우 `EXISTS` 절 대신 `IN`. `IN` 는 쉼표로 구분된 값 목록과 함께 사용되며, 이렇게 하면 쿼리의 계산 비용이 증가합니다.

When `IN` 쿼리가 실행되면 시스템은 먼저 하위 쿼리를 처리해야 합니다. `IN` 문)을 클릭한 다음 `IN` 문. `EXISTS` 쿼리에 지정된 관계를 확인하는 동안 true/false 값을 반환하므로 쿼리를 여러 번 실행할 필요가 없으므로 훨씬 효율적입니다.

간단히 말하자면, 사용 시 시스템이 처리할 필요가 없습니다 `EXISTS`.

| **이 대신...** | **한번 해 봐!** |
|-----|-----|
| ![](../../mbi/assets/Exists_1.png) | ![](../../mbi/assets/Exists_2.png) |

{style=&quot;table-layout:auto&quot;}

## 정렬 기준 사용

`ORDER BY` 는 SQL에서 매우 비싼 함수로 쿼리 비용을 크게 높일 수 있습니다. 쿼리의 EXPLAIN 비용이 너무 높다는 오류 메시지가 표시되면 해당 항목을 제거해 보십시오 `ORDER BY`절대적으로 필요하지 않은 한 쿼리에서 가져옵니다.

이것은 그런 말이 아니다 `ORDER BY` 사용할 수 없습니다. 필요할 때만 사용해야 합니다.

## 그룹 기준 및 정렬 기준 사용

이러한 접근 방식이 수행하려는 방식과 일치하지 않는 경우가 있을 수 있지만 일반적인 규칙은 를 사용하는 경우입니다 `GROUP BY` 및 `ORDER BY`를 지정하는 경우 두 절 모두에 열을 같은 순서로 배치해야 합니다. 예:

| **이 대신...** | **한번 해 봐!** |
|-----|-----|
| ![](../../mbi/assets/Group_by_2.png) | ![](../../mbi/assets/Group_by_1.png) |

{style=&quot;table-layout:auto&quot;}

## 포장

SQL을 효율적으로 작성하고 기록하는 가장 좋은 방법은 시행착오를 통한 것입니다. 가장 적합한 항목을 찾으려면 SQL 편집기만 사용하여 몇 개의 보고서를 다시 만드십시오.
